

DISK_IO_OK = 0
DISK_IO_ERR = 1
SETNAM = $FFBD
SETLFS = $FFBA
OPEN = $FFC0
LOAD = $FFD5
CLOSE = $FFC3
CLRCHN = $FFCC
SAVE = $FFD8
CHKIN = $FFC6
READST = $FFB7
CHRIN = $FFCF
TMP_PTR = $03

; Device number used for load and save
DEVICE_NUM
!byte 8

; Contains error number of disk operation
DISK_ERROR
!byte 0

!macro loadFile .addrFileName, .fileNameLen, .deviceNumAddr, .targetAddr {
    ; open 1,DEVICE_NUM,0,"..."
    lda #.fileNameLen
    ldx #<.addrFileName
    ldy #>.addrFileName
    jsr SETNAM

    lda #$01                          ; logical file number 1
    ldx .deviceNumAddr
    ldy #$00                          ; secondary address 0 
    jsr SETLFS

    ; set address of receiving buffer
    ldx #<.targetAddr
    ldy #>.targetAddr
    lda #$00                          ; do load instead of a verify
    jsr LOAD
    jsr readAndEvalErrorChannel
    lda DISK_ERROR
}


ERR_BYTE_COUNTER
!byte $00
ERROR_MSG_BUFFER
!byte $00, $00, $00, $00, $00, $00, $00, $00
!byte $00, $00, $00, $00, $00, $00, $00, $00
!byte $00, $00, $00, $00, $00, $00, $00, $00
!byte $00, $00, $00, $00, $00, $00, $00, $00
; --------------------------------------------------
; readErrorChannel Reads the current drive status. This can lock up
; if device DEVICE_NUM is not present
; 
; INPUT:  None
; OUTPUT: error code in accu.
; --------------------------------------------------
readErrorChannel
    ; reset previous error
    lda #DISK_IO_OK
    sta DISK_ERROR

    ; set error code to "00", ie OK
    lda #48
    sta ERROR_MSG_BUFFER
    sta ERROR_MSG_BUFFER + 1
    ; open 15,8,15
    lda #0                            ; no file name
    ldx #0
    ldy #0
    jsr SETNAM

    lda #15                           ; logical file number 15
    ldx DEVICE_NUM                   ; device number
    ldy #15                           ; secondary address 15
    jsr SETLFS

    jsr OPEN                          ; open error channel
    bcs .checkError                   ; open failed

    ldx #15
    jsr CHKIN                         ; use file 15 as input

    lda #0
    sta ERR_BYTE_COUNTER             ; set buffer index to 0
.loopErrorChannel
    jsr READST                        ; read status word
    bne .close                        ; test for eof/error
    jsr CHRIN                         ; read character from error channel
    ldx ERR_BYTE_COUNTER
    cpx #32                           ; have we exhausted the buffer size?
    beq .loopErrorChannel             ; yes => do not store the received byte, but continue to read in order to drain error channel
    sta ERROR_MSG_BUFFER, X           ; there is room left in the buffer => store byte
    inx                               ; advance index to next storage location
    stx ERR_BYTE_COUNTER
    jmp .loopErrorChannel             ; read next byte

.close 
    lda #15                           
    jsr CLOSE                         ; close file 15
    jsr CLRCHN                        ; restore default input and output channels

    rts
.checkError
    ; room for additional error handling
    lda #DISK_IO_ERR
    sta DISK_ERROR
    jmp .close                        ; even if open failed we have to close the file


; --------------------------------------------------
; readAndevalErrorChannel Reads the current drive status and evaluates the
; returned message. This can lock up if device DEVICE_NUM is not present.
; 
; INPUT:  None
; OUTPUT: error code in accu. This value is also saved in DISK_ERROR.
; --------------------------------------------------
readAndEvalErrorChannel
    jsr readErrorChannel
    lda DISK_ERROR
    bne .doneEvalErr
    +load16BitImmediate ERROR_MSG_BUFFER, TMP_PTR
    jsr asciiToByte
    sta DISK_ERROR
    rts
.doneEvalErr
    ; truncate error message string as it may be corrupt
    lda #0
    sta ERR_BYTE_COUNTER

    rts


.ERR_CODE_CONV_HELP
!byte $00
; --------------------------------------------------
; asciiToByte converts the two digit string referenced via TMP_PTR 
; to a numeric value that is stored in the accu
; 
; INPUT:  TMP_PTR is set to buffer
; OUTPUT: Numeric value in accu
; --------------------------------------------------
asciiToByte
    ldy #0
    lda (TMP_PTR), y
    sec
    sbc #48
    tax                              ; save value of first char
    asl
    asl              
    asl                              ; accu = accu * 8
    sta .ERR_CODE_CONV_HELP
    txa                              ; restore original value
    asl                              ; accu = accu * 2 
    clc
    adc .ERR_CODE_CONV_HELP          ; accu now contains value of first digit
    sta .ERR_CODE_CONV_HELP          ; store original_value * 8 + original_value * 2 = original_value * 10 
    iny
    lda (TMP_PTR), y
    sec
    sbc #48                          ; add value of second digit
    clc
    adc .ERR_CODE_CONV_HELP
    clc

    rts