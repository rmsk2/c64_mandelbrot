GETIN   = $FFE4

HEX_CHARS
!tx "0123456789ABCDEF"

CHAROUT = $FFD2
TEMP_PTR = $03
TEMP_PTR2 = $05

LO_NIBBLE
!byte 0

; --------------------------------------------------
; This routine prints a fixed point number to the screen. The address
; of the number has to be given in $0003/$0004
;
; The number of iterations performed is returned in NUM_ITER 
; --------------------------------------------------
printNumHex
    ldy #0
    lda (TEMP_PTR), y
    bne .printMinus
    lda #43
    jsr CHAROUT
    jmp .egal
.printMinus
    lda #45
    jsr CHAROUT
.egal

    ldy #4
.loopPrint
    lda (TEMP_PTR), y
    jsr printByte
    dey
    bne .loopPrint
    jsr printCRLF
    rts

!macro printFixedPoint .addr {
    lda #<.addr
    sta TEMP_PTR
    lda #>.addr
    sta TEMP_PTR+1
    jsr printNumHex
} 

printByteCRLF
    jsr printByte
    jsr printCRLF
    rts

printByte
    jsr splitByte
    stx LO_NIBBLE
    tax
    lda HEX_CHARS, X
    jsr CHAROUT
    ldx LO_NIBBLE
    lda HEX_CHARS, X
    jsr CHAROUT
    rts

printCRLF
    lda #13
    jsr CHAROUT
    lda #10
    jsr CHAROUT
    rts

.CONV_TEMP
!byte 0
; --------------------------------------------------
; This routine splits the value in accu its nibbles. The lower nibble 
; is returned in x and its upper nibble in the accu
; --------------------------------------------------
splitByte
    sta .CONV_TEMP
    and #$0F
    tax
    lda .CONV_TEMP
    and #$F0
    lsr
    lsr 
    lsr 
    lsr
    rts

!macro printByteLN .addr {
    lda .addr
    jsr printByteCRLF
}

ARG1
!byte 1,0,0,$c0,0
ARG2
!byte 0,0,0,$20,0
DUMMY
!byte 0 
testAdd 
    +printFixedPoint ARG1
    +printFixedPoint ARG2
    lda #0
    sta DUMMY
    +callFunc cmp32BitUnsigned, ARG1, ARG2
    bcc .eval
    lda #1
    sta DUMMY
.eval 
    lda DUMMY
    jsr printByteCRLF

    +callFunc add32Bit, ARG1, ARG2
    +printFixedPoint ARG2

    rts

; --------------------------------------------------
; Wait for a key and return ASCII Code of key in Accumulator
; 
; INPUT:  None
; OUTPUT: ASCII code of read character in accumulator
; --------------------------------------------------
waitForKey
    jsr GETIN         ; get key from keyboard
    cmp #0            ; if 0, no key pressed
    beq waitForKey    ; loop if no key pressed

    rts               ; ASCII Code of pressed key is now in accumulator


STR_LEN_TEMP
!byte 0
; --------------------------------------------------
; This routine copies a string referenced via TEMP_PTR to a string
; referenced by TEMP_PTR2. The first byte of a string is a length
; value followed by the characters of the string. The maximum length
; of a string including the length byte es 255 bytes. This also means
; that a sting can contain at most 254 characters.
; --------------------------------------------------
stringCopy
    ldy #0
    lda (TEMP_PTR),y
    sta STR_LEN_TEMP
    inc STR_LEN_TEMP                      ; take length byte into account
.copyLoop
    lda (TEMP_PTR),y
    sta (TEMP_PTR2),y
    iny
    cpy STR_LEN_TEMP
    bne .copyLoop    
    rts

!macro strCpy .addr1, .addr2 {
    +load16BitImmediate .addr1, TEMP_PTR
    +load16BitImmediate .addr2, TEMP_PTR2
    jsr stringCopy
}


PRINT_LEN
!byte 0
; --------------------------------------------------
; This routine prints a string referenced via TEMP_PTR to the screen
; --------------------------------------------------
printString
    ldy #0
    lda (TEMP_PTR),Y                   ; load length byte
    sta PRINT_LEN
    +inc16Bit TEMP_PTR                 ; move pointer to first byte of string
.loopPrintStr
    cpy PRINT_LEN                      ; check current print index first to handle zero length strings correctly
    beq .printDone
    lda (TEMP_PTR),y
    jsr CHAROUT
    iny
    jmp .loopPrintStr
.printDone
    rts

!macro printStr .addr {
    +load16BitImmediate .addr, TEMP_PTR
    jsr printString
}

SAVE_NAME_LEN
!byte 21
DEFAULT_FILE_NAME_SAVE
!tx "@0:MANDELBROT.PIC,S,W"
setFileNameAndGo
    +strCpy SAVE_NAME_LEN, PIC_FILE_NAME_LEN
    jmp mandelLoop


LOAD_NAME_LEN
!byte 20
DEFAULT_FILE_NAME_LOAD
!tx "0:MANDELBROT.PIC,S,R"
;!tx "0:APFEL.GR1"
setFileNameAndLoad
    +strCpy LOAD_NAME_LEN, PIC_FILE_NAME_LEN
    jsr loadAndDisplayPic
    lda DISK_ERROR
    beq .waitForKey                      ; zero value in accu => load successfull
    jsr bitMapOff
    jsr printCRLF
    +printStr ERR_BYTE_COUNTER
    jsr printCRLF
    rts
.waitForKey
    jsr waitForKey
    jsr bitMapOff
    rts
