

VIC = $D000
BITMAP = $2000
BITMAP_END = BITMAP + 8192
COLOR_DATA = $0400
COLOR_RAM = $D800

ADDR_POINTER = $9E;/$9F
ADDR_POINTER2 = $03;/$04
ZP_HELPADR1 = ADDR_POINTER2

!macro memsetImmediate .val, .startAddr, .numBlocks {
    lda #.val
    sta MEM_VAL

    lda #<.startAddr
    sta ADDR_POINTER
    lda #>.startAddr+1
    sta ADDR_POINTER+1
    
    lda #.numBlocks
    sta TEMP_NUM_BLOCKS
    jsr memsetCall
}

!macro memsetAddr .colAddr, .startAddr, .numBlocks {
    lda .colAddr
    sta MEM_VAL

    lda #<.startAddr
    sta ADDR_POINTER
    lda #>.startAddr+1
    sta ADDR_POINTER+1
    
    lda #.numBlocks
    sta TEMP_NUM_BLOCKS
    jsr memsetCall
}


; --------------------------------------------------
; This routine turns the hires mode on
; --------------------------------------------------
initHiRes
    +memsetImmediate 0, BITMAP, 32
turnHiresOn
    ; turn hires bitmap on
    lda VIC+17
    ora #%00100000
    sta VIC+17
    ; move bitmap memory to $2000 => set bit 3
    lda VIC+24
    ora #%00001000
    sta VIC+24

resetColors
    +memsetAddr PIC_COLOURS, COLOR_DATA, 4

    rts

; --------------------------------------------------
; This routine turns the multicolor bit map mode on
; --------------------------------------------------
initMuticolor
    +memsetImmediate 0, BITMAP, 32
turnMulticolorOn
    ; turn hires bitmap on
    lda VIC+17
    ora #%00100000
    sta VIC+17
    ; move bitmap memory to $2000 => set bit 3
    lda VIC+24
    ora #%00001000
    sta VIC+24
    ; turn muticolor on
    lda VIC+22                         
    ora #%00010000                     
    sta VIC+22    

resetMulticolors
    +memsetAddr PIC_COLOURS, COLOR_DATA, 4
    +memsetAddr THIRD_COLOUR, COLOR_RAM, 4
    lda BACKGROUND_COLOR
    sta 53281

    rts


; --------------------------------------------------
; This routine turns the hires mode off
; --------------------------------------------------
deInitHires
    ; turn hires bitmap off
    lda VIC+17
    and #%11011111
    sta VIC+17
    ; clear bit 3 again
    lda VIC+24
    and #%11110111
    sta VIC+24

    +memsetImmediate 32, COLOR_DATA, 4

    rts 

; --------------------------------------------------
; This routine turns the  multicolor mode off
; --------------------------------------------------
deInitMulticolor
    ; turn hires bitmap off
    lda VIC+17
    and #%11011111
    sta VIC+17
    ; clear bit 3 again
    lda VIC+24
    and #%11110111
    sta VIC+24
    ; turn muticolor off
    lda VIC+22                         
    and #%11101111                     
    sta VIC+22    

    +memsetImmediate 32, COLOR_DATA, 4
    +memsetAddr 0, COLOR_RAM, 4    

    rts 


MEM_VAL
!byte 0
TEMP_NUM_BLOCKS
!byte 0
; --------------------------------------------------
; This routine sets all bytes of the referenced memory to a
; specified value.
; 
; ADDR_POINTER          has to contain the start address of the memory area
; TEMP_NUM_BLOCKS       has to contain the number of 256 byte blocks to clear
; MEM_VAL               has to contain the value to which memory is set
; --------------------------------------------------
memsetCall
    ldy #0
    ldx TEMP_NUM_BLOCKS
    lda MEM_VAL
.processBlock 
    sta (ADDR_POINTER), y
    iny
    bne .processBlock
    inc ADDR_POINTER+1
    dex
    bne .processBlock
    
    rts

!macro memcpyAddr .addrSource, .addrTarget, .numBlocks {
    lda #.numBlocks
    sta TEMP_NUM_BLOCKS
    +load16BitImmediate .addrSource, ADDR_POINTER
    +load16BitImmediate .addrTarget, ADDR_POINTER2

    jsr memcpyCall
}

; --------------------------------------------------
; This routine copies a number of 256 byte blocks between two addresses. The two memory
; areas must not overlap
; 
; ADDR_POINTER          has to contain the start address of the source memory area
; ADDR_POINTER2         has to contain the start address of the target memory area
; TEMP_NUM_BLOCKS       has to contain the number of 256 byte blocks to copy
; --------------------------------------------------
memcpyCall
    ldy #0
    ldx TEMP_NUM_BLOCKS
.processBlockCpy
    lda (ADDR_POINTER), y
    sta (ADDR_POINTER2), y
    iny
    bne .processBlockCpy
    inc ADDR_POINTER+1
    inc ADDR_POINTER2+1
    dex
    bne .processBlockCpy
    
    rts


PLOT_POS_X
!byte 0,0
PLOT_POS_Y
!byte 0
PLOT_COL
!byte 0

; --------------------------------------------------
; This routine sets a point in the multixolor bitmap. Inefficient but sufficient ;-)
; 
; PLOT_POS_X            has to contain the x position of the point
; PLOT_POS_Y            has to contain the y position of the point
; PLOT_COL              has to contain the number of the color (0-3)
; --------------------------------------------------
setPointMulticolor
    lda #0
    sta PLOT_POS_X+1                                ; clear hi byte of POS_X
    +double16Bit PLOT_POS_X                         ; Multiply xpos by two
    lda PLOT_COL                  
    and #1                                          ; is bit 0 in color number set?
    beq .skipPixelOne                               ; No => do not plot. Look at bit 1
    jsr setPoint                                    ; Yes => set first bit
.skipPixelOne
    lda PLOT_COL                                    ; is bit 1 of color number set?
    and #2
    beq .skipPixelTwo                               ; No => do not plot
    +inc16Bit PLOT_POS_X                            ; select pixel to the right
    jsr setPoint                                    ; set it
.skipPixelTwo
    rts

; prevent Assembling buggy JMP($xxff) instruction in repl.a and main.a
;
; The original 6502 processor has a bug: When executing an indirect
; JMP instruction where the low byte of the argument equals $ff, it
; fetches the high byte of the jump target address not from memory
; location ARGUMENT+1, but from ARGUMENT-255. Therefore ACME issues
; this warning if you are about to generate such an instruction.
!skip 4

; --------------------------------------------------
; This routine sets a point in the hires bitmap. 
; source: https://www.retro-programming.de/programming/nachschlagewerk/vic-ii/vic-ii-grafikmodes-bitmap-hi-res/
; 
; PLOT_POS_X            has to contain the x position of the point
; PLOT_POS_Y            has to contain the y position of the point
; --------------------------------------------------
setPoint
    ;Bitmap-Adresse auf die Zero-Page
    +load16BitImmediate BITMAP, ZP_HELPADR1
    ldy PLOT_POS_Y
    ldx PLOT_POS_X
    lda PLOT_POS_X+1
    lsr                                ; move MSB of x pos into carry
    bcc .skip                          ;falls Carry gelöscht weiter -> .skip
    inc ZP_HELPADR1+1                  ;sonst MSB+1
    clc                                ;und C wieder löschen (für ADC)
.skip
    txa                                ;X in den Akku
    pha                                ;und für später merken
    and #%11111000                     ;'Pixel'-Position ausblenden
    adc ZP_HELPADR1                    ;Anzahl der Bytes für X-Position addieren
    sta ZP_HELPADR1                    ;und speichern
    bcc .skip1                         ;falls C gelöscht ist weiter -> .skip1
    inc ZP_HELPADR1+1                  ;sonst MSB wegen gesetztem Carry erhöhen
.skip1
    tya                                ;Y in den Akku
    pha                                ;und merken
    lsr                                ;jetzt durch 8 teilen
    lsr
    lsr
    beq .skip2
    tay
.loop
    ;Für jede 'Textzeile' 320 Bytes addieren
    +add16BitImmediate 320, ZP_HELPADR1
    dey
    bne .loop
.skip2
    pla
    and #%00000111                     ;Bytes für die 'Ziel-Textzeile'
    tay                                ;ins Y-Register (für Y-nach-indizierte-Adr.)
    pla                                ;jetzt noch die BIT-Position (X) berechnen
    and #%00000111
    tax
    lda #$00
    sec
.loop1
    ror                                ;Zielpixel 'einrotieren'
    dex
    bpl .loop1                         ;wiederhole, solange X positiv
    ora (ZP_HELPADR1),Y                ;mit bisherigen Wert ODER-Verknüpfen
    sta (ZP_HELPADR1),Y                ;und speichern
    rts                                ;zurück zum Aufrufer
